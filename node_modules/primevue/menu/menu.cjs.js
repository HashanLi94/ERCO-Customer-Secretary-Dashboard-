'use strict';

var utils = require('primevue/utils');
var Ripple = require('primevue/ripple');
var vue = require('vue');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Ripple__default = /*#__PURE__*/_interopDefaultLegacy(Ripple);

var script = {
    inheritAttrs: false,
    emits: ['click'],
    props: {
        item: null
    },
    methods: {
        onClick(event, navigate) {
            this.$emit('click', {
                originalEvent: event,
                item: this.item,
                navigate: navigate
            });
        },
        visible() {
            return (typeof this.item.visible === 'function' ? this.item.visible() : this.item.visible !== false);
        }
    },
    computed: {
        containerClass() {
            return ['p-menuitem', this.item.class];
        },
        linkClass() {
            return ['p-menuitem-link', {'p-disabled': this.item.disabled}];
        }
    },
    directives: {
        'ripple': Ripple__default['default']
    }
};

const _hoisted_1 = { class: "p-menuitem-text" };
const _hoisted_2 = { class: "p-menuitem-text" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = vue.resolveComponent("router-link");
  const _directive_ripple = vue.resolveDirective("ripple");

  return ($options.visible())
    ? (vue.openBlock(), vue.createBlock("li", {
        key: 0,
        class: $options.containerClass,
        role: "none",
        style: $props.item.style
      }, [
        ($props.item.to && !$props.item.disabled)
          ? (vue.openBlock(), vue.createBlock(_component_router_link, {
              key: 0,
              to: $props.item.to,
              custom: ""
            }, {
              default: vue.withCtx(({navigate, href}) => [
                vue.withDirectives(vue.createVNode("a", {
                  href: href,
                  onClick: $event => ($options.onClick($event, navigate)),
                  class: $options.linkClass,
                  role: "menuitem"
                }, [
                  vue.createVNode("span", {
                    class: ['p-menuitem-icon', $props.item.icon]
                  }, null, 2),
                  vue.createVNode("span", _hoisted_1, vue.toDisplayString($props.item.label), 1)
                ], 10, ["href", "onClick"]), [
                  [_directive_ripple]
                ])
              ]),
              _: 1
            }, 8, ["to"]))
          : vue.withDirectives((vue.openBlock(), vue.createBlock("a", {
              key: 1,
              href: $props.item.url,
              class: $options.linkClass,
              onClick: _cache[1] || (_cache[1] = (...args) => ($options.onClick && $options.onClick(...args))),
              target: $props.item.target,
              role: "menuitem",
              tabindex: $props.item.disabled ? null : '0'
            }, [
              vue.createVNode("span", {
                class: ['p-menuitem-icon', $props.item.icon]
              }, null, 2),
              vue.createVNode("span", _hoisted_2, vue.toDisplayString($props.item.label), 1)
            ], 10, ["href", "target", "tabindex"])), [
              [_directive_ripple]
            ])
      ], 6))
    : vue.createCommentVNode("", true)
}

script.render = render;

var script$1 = {
    props: {
        popup: {
            type: Boolean,
            default: false
        },
		model: {
            type: Array,
            default: null
        },
        appendTo: {
            type: String,
            default: null
        },
        autoZIndex: {
            type: Boolean,
            default: true
        },
        baseZIndex: {
            type: Number,
            default: 0
        }
    },
    data() {
        return {
            overlayVisible: false
        };
    },
    target: null,
    outsideClickListener: null,
    scrollHandler: null,
    resizeListener: null,
    relativeAlign: false,
    container: null,
    beforeUnmount() {
        this.restoreAppend();
        this.unbindResizeListener();
        this.unbindOutsideClickListener();

        if (this.scrollHandler) {
            this.scrollHandler.destroy();
            this.scrollHandler = null;
        }
        this.target = null;
        this.container = null;
    },
    methods: {
        itemClick(event) {
            const item = event.item;
            if (item.disabled) {
                return;
            }

            if (item.command) {
                item.command(event);
            }

            if (item.to && event.navigate) {
                event.navigate(event.originalEvent);
            }

            this.hide();
        },
        toggle(event) {
            if (this.overlayVisible)
                this.hide();
            else
                this.show(event);
        },
        show(event) {
            this.overlayVisible = true;
            this.relativeAlign = event.relativeAlign;
            this.target = event.currentTarget;
        },
        hide() {
            this.overlayVisible = false;
            this.target = null;
            this.relativeAlign = false;
        },
        onEnter() {
            this.appendContainer();
            this.alignOverlay();
            this.bindOutsideClickListener();
            this.bindResizeListener();
            this.bindScrollListener();

            if (this.autoZIndex) {
                this.container.style.zIndex = String(this.baseZIndex + utils.DomHandler.generateZIndex());
            }
        },
        onLeave() {
            this.unbindOutsideClickListener();
            this.unbindResizeListener();
            this.unbindScrollListener();
        },
        alignOverlay() {
            if (this.relativeAlign)
                utils.DomHandler.relativePosition(this.container, this.target);
            else
                utils.DomHandler.absolutePosition(this.container, this.target);

        },
        bindOutsideClickListener() {
            if (!this.outsideClickListener) {
                this.outsideClickListener = (event) => {
                    if (this.overlayVisible && this.container && !this.container.contains(event.target) && !this.isTargetClicked(event)) {
                        this.hide();
                    }
                };
                document.addEventListener('click', this.outsideClickListener);
            }
        },
        unbindOutsideClickListener() {
            if (this.outsideClickListener) {
                document.removeEventListener('click', this.outsideClickListener);
                this.outsideClickListener = null;
            }
        },
        bindScrollListener() {
            if (!this.scrollHandler) {
                this.scrollHandler = new utils.ConnectedOverlayScrollHandler(this.target, () => {
                    if (this.overlayVisible) {
                        this.hide();
                    }
                });
            }

            this.scrollHandler.bindScrollListener();
        },
        unbindScrollListener() {
            if (this.scrollHandler) {
                this.scrollHandler.unbindScrollListener();
            }
        },
        bindResizeListener() {
            if (!this.resizeListener) {
                this.resizeListener = () => {
                    if (this.overlayVisible) {
                        this.hide();
                    }
                };
                window.addEventListener('resize', this.resizeListener);
            }
        },
        unbindResizeListener() {
            if (this.resizeListener) {
                window.removeEventListener('resize', this.resizeListener);
                this.resizeListener = null;
            }
        },
        isTargetClicked() {
            return this.target && (this.target === event.target || this.target.contains(event.target));
        },
        appendContainer() {
            if (this.appendTo) {
                if (this.appendTo === 'body')
                    document.body.appendChild(this.container);
                else
                    document.getElementById(this.appendTo).appendChild(this.container);
            }
        },
        restoreAppend() {
            if (this.container && this.appendTo) {
                if (this.appendTo === 'body')
                    document.body.removeChild(this.container);
                else
                    document.getElementById(this.appendTo).removeChild(this.container);
            }
        },
        visible(item) {
            return (typeof item.visible === 'function' ? item.visible() : item.visible !== false);
        },
        containerRef(el) {
            this.container = el;
        }
    },
    computed: {
        containerClass() {
            return ['p-menu p-component', {
                'p-menu-overlay': this.popup
            }]
        }
    },
    components: {
        'Menuitem': script
    }
};

const _hoisted_1$1 = {
  class: "p-menu-list p-reset",
  role: "menu"
};
const _hoisted_2$1 = {
  key: 0,
  class: "p-submenu-header"
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Menuitem = vue.resolveComponent("Menuitem");

  return (vue.openBlock(), vue.createBlock(vue.Transition, {
    name: "p-connected-overlay",
    onEnter: $options.onEnter,
    onLeave: $options.onLeave
  }, {
    default: vue.withCtx(() => [
      ($props.popup ? $data.overlayVisible : true)
        ? (vue.openBlock(), vue.createBlock("div", {
            key: 0,
            ref: $options.containerRef,
            class: $options.containerClass
          }, [
            vue.createVNode("ul", _hoisted_1$1, [
              (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($props.model, (item, i) => {
                return (vue.openBlock(), vue.createBlock(vue.Fragment, {
                  key: item.label+i
                }, [
                  (item.items && $options.visible(item) && !item.separator)
                    ? (vue.openBlock(), vue.createBlock(vue.Fragment, { key: 0 }, [
                        (item.items)
                          ? (vue.openBlock(), vue.createBlock("li", _hoisted_2$1, vue.toDisplayString(item.label), 1))
                          : vue.createCommentVNode("", true),
                        (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(item.items, (child, j) => {
                          return (vue.openBlock(), vue.createBlock(vue.Fragment, {
                            key: child.label + i + j
                          }, [
                            ($options.visible(child) && !child.separator)
                              ? (vue.openBlock(), vue.createBlock(_component_Menuitem, {
                                  key: 0,
                                  item: child,
                                  onClick: $options.itemClick
                                }, null, 8, ["item", "onClick"]))
                              : ($options.visible(child) && child.separator)
                                ? (vue.openBlock(), vue.createBlock("li", {
                                    class: ['p-menu-separator', child.class],
                                    style: child.style,
                                    key: 'separator' + i + j,
                                    role: "separator"
                                  }, null, 6))
                                : vue.createCommentVNode("", true)
                          ], 64))
                        }), 128))
                      ], 64))
                    : ($options.visible(item) && item.separator)
                      ? (vue.openBlock(), vue.createBlock("li", {
                          class: ['p-menu-separator', item.class],
                          style: item.style,
                          key: 'separator' + i,
                          role: "separator"
                        }, null, 6))
                      : (vue.openBlock(), vue.createBlock(_component_Menuitem, {
                          key: item.label+i,
                          item: item,
                          onClick: $options.itemClick
                        }, null, 8, ["item", "onClick"]))
                ], 64))
              }), 128))
            ])
          ], 2))
        : vue.createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["onEnter", "onLeave"]))
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "\n.p-menu-overlay {\n    position: absolute;\n}\n.p-menu ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n}\n.p-menu .p-menuitem-link {\n    cursor: pointer;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n}\n.p-menu .p-menuitem-text {\n    line-height: 1;\n}\n";
styleInject(css_248z);

script$1.render = render$1;

module.exports = script$1;
